options { STATIC=false;}
PARSER_BEGIN(Parser)
package plg.proto;

import java.util.*;

class Parser{
}

PARSER_END(Parser)
  
  /* Reglas lexicas */
  SKIP:{<["\t"," ", "\r","\b","\n"]>}
  TOKEN:{<OR:"or">}
  TOKEN:{<AND:"and">}
  TOKEN:{<IF:"if">}
  TOKEN:{<FI:"fi">}
  TOKEN:{<THEN:"then">}
  TOKEN:{<ELSE:"else">}
  TOKEN:{<TRUE:"true">}
  TOKEN:{<FALSE:"false">}
  TOKEN:{<WRITE:"write">}
  TOKEN:{<PAP:"(">}
  TOKEN:{<PCIERRE:")">}
  TOKEN:{<STRING:"\""(~["\""])*"\"">}

/* Reglas sintacticas */
void s(Attr a) : 
	{
		Attr ia;
	}{
		ia=Attr.create().etqh(0)
		i(ia)
		<EOF>
		a.cod(ia.cod())
	}

void i(Attr a) :
	{
		Attr ea, ia1, ia2;
	}{
		<IF>
		ea = Attr.copy(a)
		e(ea)
		<THEN>
		ia1 = Attr.create().etqh(ea.etq() + 1)
		i(ia1)
		<ELSE>
		ia2 = Attr.create().etqh(ia1.etq() + 1)
		i(ia2)
		<FI>
		a.etq(ia2.etq())
	|
		<WRITE>
		<STRING>
		a.etq(a.etqh() + 2)
	}
	
void e (Attr a) :
	{
		Attr ta, rea;
	}{
		ta = Attr.copy(a)
		t(ta)
		rea = Attr.create().etqh(ta.etq()).lirvh(ta.lirv()).lirfh(ta.lirf())
		re(rea)
		a.cod(rea.cod())
		a.etq(rea.etq())
	}
	
void re (Attr a) :
	{
		
	}{
	
	}
	
void t (Attr a) :
	{
	
	}{
	
	}
	
void rt (Attr a) :
	{
	
	}{
	
	}
	
void f (Attr a) :
	{
	
	}{
	
	}
	